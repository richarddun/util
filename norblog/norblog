#!/usr/local/bin/python2.7
"""
    Script to read a range of OrbLog files generated by Citrix CloudBridge Diagnostic
    bundle (log.tgz) and output to human readable text file.

    Richard Dunne, 2015
    richard.w.dunne@gmail.com

    Usage : ./norblog /path/to/extracted/log/directory

    Output : Script will write text logs to - orb_log.txt ; if the orb_log.txt file
    already exists, a seperate file (orb_log_date&time_of_run.txt) will be created instead

    This script will not read connection state information, only system logs and alerts

    The means to decode log files already exists via the Citrix CloudBridge plugin (with the '-a' switch) 
    on Windows however this script allows the same functionality in a *nix environment.


This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>
"""

#v2.3

import os
import sys
import struct
import time
import subprocess
import argparse

def by_record_int(list):
    """
    function to return comparison between log.'0'.1111.OrbLog and log.'10'.1122.OrbLog
    """
    return int(list.split('.')[1])

def filelist(string):
    """
    Takes path and returns sorted list of orblog filenames from directory at
    the path.  Files are sorted by the first integer in the filename.  Current.OrbLog
    gets placed at the beginning of the list before returning the list.
    """
    filelist = []
    command_string = "ls " + string + " | grep OrbLog | grep -v Debug"
    for line in subprocess.check_output([command_string], shell=True).splitlines():
        filelist.append(line)
    temp = filelist.pop(0) #need to pop the record 'Current.OrbLog' due to 'sorted' requirements
    retlist = sorted(filelist, key = by_record_int)
    retlist.append(temp) #add 'Current.Orblog' back to end of list
    return retlist, len(retlist)

def tzinfo(path):
    """
    Given a path, this function returns the offset by which epoch should be
    calculated after reading the tzinfo file (should be present in the
    directory path specified)
    """
    try:
        with open(os.path.join(path, "tzinfo"), 'r') as tz_file:
            line = tz_file.read()
            tz_string = line[-7:]
            offset = int(tz_string[1:3]) * 3600
            if tz_string[0] == "+":
                offset = -offset
            return (offset)
    except :
        print "Cannot read tzinfo file to reliably determine timezone.  Use norblog -h for help\n"
        sys.exit()

def main():
    #activity indicator
    syms = ['\\', '|', '/', '-']
    spinner = 0
    
    recbytes = 4
    filecount = 1
    parser = argparse.ArgumentParser(description ='View Warnings and Alerts from Orbital log files.  ', epilog='NOTE : Log file directory should already have been extracted prior to running this utility. The "tzinfo" file must be present in the log directory as it is required by the script to write the appropriate timestamps.  If the file is missing you may simply run : "[user@server]$ echo "UTC+00:00" > tzinfo in the log directory.  Then the script will run (though the correct timestamps may be skewed due to missing timezone)\n')
    group1 = parser.add_argument_group('required arguments')
    group1.add_argument("path", help="Path to extracted logfiles")
    args = parser.parse_args()
    path = args.path

    if os.path.exists(os.path.join(path, 'orb_log.txt')):
        orblog_out = "orb_log_" + time.strftime("%d-%m-%Y:%H:%M:%S") + "_.txt" # if there's already orb_log.txt, create a new one
    else:
        orblog_out = "orb_log.txt"

    if os.path.exists(path):
        time_offset = tzinfo(path)
        params = os.path.join(path, orblog_out)
        sys.stdout.write('Working... Please stand by, this can take time for large numbers of files...\n')
        with open(params, 'a') as outlog:
            files, filenum = filelist(path)
            for file in files:
                sys.stdout.write('Parsing File #' +str(filecount) +' of ' + str(filenum) + ' - {:.2%} done '.format(float(filecount)/float(filenum)))
                sys.stdout.write('\r')
                sys.stdout.flush()
                with open(os.path.join(path, file), 'rb') as infile:
                    memfile = infile.read()
                outlog.write('Current file : ' + str(file) + '\n')
                header = struct.unpack('4i',memfile[0:16])
                index, recordstart, recordend = 16, header[2], header[3]
                recordnum = recordend - recordstart

                for segment in range(recordnum): #only operate on n number of records per file
                    current_record_len = struct.unpack('i', memfile[index:index+recbytes])[0] #find actual length of record from header
                    read_size = index + current_record_len #update current location in string for unpacking
                    current_record = memfile[index+recbytes:read_size] #take the current record from the string
                    clean_record = current_record.replace('\x00','') #remove null bytes
                    record_header = struct.unpack('<lc',current_record[:5]) #read record type and timestamp
                    if (record_header[1] == '\x03') or (record_header[1] == '\x02'):
                        timestamp = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(record_header[0]+time_offset))
                        outlog.write(timestamp)
                        outlog.write(' ' + clean_record[5:] + '\n')
                    index = read_size
                filecount += 1
    else:
        print "Folder doesn't exist or no permissions to write\nCheck file path and re-run\n"
        sys.exit()

    sys.stdout.write('\n')
    sys.stdout.flush()
    print "\nOutput file : " + str(orblog_out) + "\n"

if __name__ == '__main__':
    main()


